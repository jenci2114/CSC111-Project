"""CSC111 Final Project: AI Player in Chinese Chess

Module Description
===============================

This Python module contains functions that can be
used to train a LearningPlayer (a Player subclass
found in player.py).

Copyright and Usage Information
===============================

This file is Copyright (c) 2021 Junru Lin, Zixiu Meng, Krystal Miao, Jenci Wei
"""
import chess_game
from chess_game import ChessGame
import game_tree
from player import LearningPlayer, AIBlack, ExploringPlayer
import game_run

RECORDING_RATE = 0.5


def train_exploring_for_probability(tree_file: str, number: int, depth: int) -> None:
    """Train the AI Player with iterations in tree_file number times, using LearningPlayer with
    exploring depth being depth.

    In each round of training, the function only records the moves the Players choose, and
    will add sequence of moves in each round to the tree. The probability of the whole tree
    will be updated in each round.

    Preconditions:
        - tree_file must be a file generated by the tree_to_xml function
        - rounds > 0
        - depth > 0
    """
    tree = game_tree.xml_to_tree(tree_file)
    for i in range(number):
        print(f'This is {i + 1} simulation')  # to trace how many times it has trained
        game = ChessGame()  # initialize a new chess game
        red = LearningPlayer(depth, tree_file)  # set red as Learning Player
        black = LearningPlayer(depth, tree_file)  # set black as Learning Player
        current_player = red  # red will make the first move

        moves_so_far = []  # to store all the moves made
        points_so_far = []  # to store the points corresponding to moves in moves_so_far
        previous_move = None  # There is no previous move

        # simulate a game
        while game.get_winner() is None:
            # the game is not ended
            # update the tree of player and get the move it makes
            previous_move = current_player.make_move(game, previous_move)
            game.make_move(previous_move)  # update the game
            board = game.get_board()  # get board to calculate the point
            moves_so_far.append(previous_move)
            points_so_far.append(chess_game.calculate_absolute_points(board))

            if current_player is red:
                current_player = black
            else:  # if current_player is black
                current_player = red

        if current_player == red:  # Black wins
            # insert the moves to the tree
            tree.insert_move_sequence(moves_so_far, points_so_far, black_win_probability=1.0)
        else:  # Red wins
            # insert the moves to the tree
            tree.insert_move_sequence(moves_so_far, points_so_far, red_win_probability=1.0)

    game_tree.tree_to_xml(tree, tree_file)


def train_exploring_for_points(xml_file: str, number: int, depth: int, turns: int) -> None:
    """Train the AI Player with tree in tree_file number iterations, using LearningPlayer with
    exploring depth being depth.

    One game will be played for [turns].

    parameters:
        - csv_file: The file of the original data
        - xml_file: The file to save the generated tree
        - number: The number of games for training
        - depth: The depth for LearningPlayer
        - turns: The number of turns a game simulates, and also the depth of the generated tree

    Preconditions:
        - tree_file must be a file generated by the tree_to_xml function
        - rounds > 0
        - depth > 0
        - turns <= 20
    """
    tree = game_tree.xml_to_tree(xml_file)
    tree.clean_depth_subtrees(turns)
    for i in range(number):
        print(f'This is {i + 1} simulation')  # to trace how many times it has trained

        # simulate a game
        game = ChessGame()  # initialize a new chess game
        red = LearningPlayer(depth, xml_file)  # set red as Learning Player
        black = LearningPlayer(depth, xml_file)  # set black as Learning Player
        current_player = red  # red will make the first move
        previous_move = None  # There is no previous move
        curr_turn = 1  # then comes the first turn
        current_tree = red.get_tree()  # to store the game tree

        while game.get_winner() is None and curr_turn <= turns:
            # update the tree of player and get the move it makes
            previous_move = current_player.make_move(game, previous_move)
            game.make_move(previous_move)  # update the game

            # update current_player for the next turn
            if current_player is red:
                current_player = black
            else:  # if current_player is black
                current_player = red
            curr_turn += 1
            print(game)

        # Add the tree of this game to the tree
        tree.merge_with(current_tree)

    game_tree.tree_to_xml(tree, xml_file)


def train_black_ai(file: str, depth: int, iterations: int) -> None:
    """Train the black ai by expanding the tree stored in file.

    This function creates an AIBlack player with the given file and the given depth. This function
    also creates an exploring player of depth 3. <iterations> number of games will be run between
    them and the tree will be stored after each game.

    Preconditions:
        - file represents a valid game tree
        - depth > 0
        - iterations > 0
    """
    for _ in range(iterations):  # How many times to train
        ai_player = AIBlack(file, depth)  # Initialize AIBlack class with given file/depth
        exploring_player = ExploringPlayer(3)  # Match AIBlack against depth-3 EP
        game_run.run_games(1, exploring_player, ai_player, True)  # Play 1 round
        ai_player.store_tree()  # Store the results


if __name__ == '__main__':
    # |------------------| For Training LearningPlayer |-----------------|

    # We will get two files. The smaller one ('data/tree_for_prob.xml') has good
    # win probability estimation and the larger one ('data/tree_for_points.xml') has
    # lots of nodes with relative points

    # |------| Prepare initial tree files |-------------|
    # If this is your firs time run this file, uncomment line 153 to 158
    # training_tree = game_tree.load_game_tree('data/middle_sample.csv')
    # game_tree.tree_to_xml(training_tree, 'data/tree_for_prob.xml')
    # training_tree = game_tree.xml_to_tree('data/tree_for_prob.xml')
    # training_tree.clean_depth_subtrees(20)
    # game_tree.tree_to_xml(training_tree, 'data/tree_for_points.xml')

    # |-------------------------------------------------------|

    # You need to choose and set player.EPSILON and game_tree.ESTIMATION

    # |------| For Training Win Probability for Tree |--------|
    # train_exploring_for_probability('data/tree_for_prob.xml', number=2000, depth=3)
    # prob_tree = game_tree.xml_to_tree('data/tree_for_prob.xml')
    # prob_tree.clean_depth_subtrees(20)
    # game_tree.tree_to_xml(prob_tree, 'data/tree_for_prob.xml')

    # |-------------------------------------------------------|

    # |------| For Training Points for Tree |-------|
    # choose number of trainings, depth for LearningPlayer and
    # the depth (turns) of the generated tree
    # train_exploring_for_points('data/tree_for_points.xml', number=1, depth=2, turns=15)

    # |---------------------------------------------|

    # |------| For Training AIBlack |-----------------------------------|
    # You can train the given tree.xml and enlarge the tree stored there:
    # Uncommented the below line:
    # train_black_ai('tree.xml', 3, 1)

    # Before you do so, make sure you change _MAX_MOVES to 10 so that it does not run long
    # After training, please change _MAX_MOVES back to 200.

    # |-----------------------------------------------------------------|

    import python_ta.contracts
    python_ta.contracts.check_all_contracts()

    # import python_ta
    # python_ta.check_all(config={
    #     'max-line-length': 100,
    #     'disable': ['E1136', 'E9998'],
    #     'extra-imports': ['chess_game', 'game_tree', 'player', 'game_run']
    # })
