"""CSC111 Final Project: AI Player in Chinese Chess

Module Description
===============================

This Python module contains training functions for AI Player.

Copyright and Usage Information
===============================

This file is Copyright (c) 2021 Junru Lin, Zixiu Meng, Krystal Miao and Jenci Wei
"""
import chess_game
from chess_game import ChessGame
import game_tree
from player import LearningPlayer

recording_rate = 0.5


def training_for_probability(tree_file: str, number: int, depth: int) -> None:
    """Train the AI Player with iterations in tree_file number times, using LearningPlayer with
    exploring depth being depth.

    In each round of training, the function only records the moves the Players choose, and
    will add sequence of moves in each round to the tree. The probability of the whole tree
    will be updated in each round.

    Preconditions:
        - tree_file must be a file generated by the tree_to_xml function
        - rounds > 0
        - depth > 0
    """
    tree = game_tree.xml_to_tree(tree_file)
    for i in range(number):
        print(i + 1)  # to trace how many times it has trained
        game = ChessGame()
        red = LearningPlayer(depth, tree_file)
        black = LearningPlayer(depth, tree_file)
        current_player = red

        moves_so_far = []
        points_so_far = []
        previous_move = None

        # simulate a game
        while game.get_winner() is None:
            previous_move = current_player.make_move(game, previous_move)
            game.make_move(previous_move)
            board = game.get_board()
            moves_so_far.append(previous_move)
            points_so_far.append(chess_game.calculate_absolute_points(board))

            if current_player is red:
                current_player = black
            else:  # if current_player is black
                current_player = red

        if current_player == red:  # Black wins
            tree.insert_move_sequence(moves_so_far, points_so_far, black_win_probability=1.0)
        else:  # Red wins
            tree.insert_move_sequence(moves_so_far, points_so_far, red_win_probability=1.0)

    game_tree.tree_to_xml(tree, tree_file)


def training_for_points(xml_file: str, number: int, depth: int, turns: int) -> None:
    """Train the AI Player with tree in tree_file number iterations, using LearningPlayer with
    exploring depth being depth.

    One game will be played for [turns].

    parameters:
        - csv_file: The file of the original data
        - xml_file: The file to save the generated tree
        - number: The number of games for training
        - depth: The depth for LearningPlayer
        - turns: The number of turns a game simulates, and also the depth of the generated tree

    Preconditions:
        - tree_file must be a file generated by the tree_to_xml function
        - rounds > 0
        - depth > 0
        - turns <= 20
    """
    tree = game_tree.xml_to_tree(xml_file)
    tree.clean_depth_subtrees(turns)
    for i in range(number):
        print(f'This is {i + 1} simulation')  # to trace how many times it has trained

        # simulate a game
        game = ChessGame()
        red = LearningPlayer(depth, xml_file)
        black = LearningPlayer(depth, xml_file)
        current_player = red
        previous_move = None
        curr_turn = 1
        current_tree = red.get_tree()

        while game.get_winner() is None and curr_turn <= turns:
            previous_move = current_player.make_move(game, previous_move)
            game.make_move(previous_move)

            # update current_player for the next turn
            if current_player is red:
                current_player = black
            else:  # if current_player is black
                current_player = red
            curr_turn += 1
            print(game)

        tree.merge_with(current_tree)

    game_tree.tree_to_xml(tree, xml_file)


if __name__ == '__main__':
    # We will get two files. The smaller one ('data/tree_for_prob.xml') has good
    # win probability estimation and the larger one ('data/tree_for_points.xml') has
    # lots of nodes with relative points

    # If this is your firs time run this file, uncomment line 131 to 134
    # training_tree = game_tree.load_game_tree('data/moves.csv')
    # game_tree.tree_to_xml(training_tree, 'data/tree_for_prob.xml')

    # training_tree = game_tree.xml_to_tree('data/tree_for_prob.xml')
    # training_tree.clean_depth_subtrees(20)
    # game_tree.tree_to_xml(training_tree, 'data/tree_for_points.xml')

    # You need to choose and set player.EPSILON and game_tree.ESTIMATION

    # Firstly, run the following block of code
    # training_for_probability('data/tree_for_prob.xml', number=2000, depth=3)
    # prob_tree = game_tree.xml_to_tree('data/tree_for_prob.xml')
    # prob_tree.clean_depth_subtrees(20)
    # game_tree.tree_to_xml(prob_tree, 'data/tree_for_prob.xml')

    # Then, run the following block of code
    # # choose number of trainings, depth for LearningPlayer and
    # # the depth (turns) of the generated tree
    training_for_points('data/tree_for_points.xml', number=1, depth=2, turns=15)
